name: CI

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: '3.11'

jobs:
  determine-packages:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.packages.outputs.packages }}
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Enumerate packages
        id: packages
        run: |
          set -euo pipefail
          packages=$(./scripts/package.py | awk '/^-/{print $2}')
          PACKAGES="$packages" python3 - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          import os
          pkgs = [p for p in os.environ.get('PACKAGES', '').splitlines() if p]
          print(f"packages={json.dumps(pkgs)}")
          PY

  lint:
    needs: determine-packages
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Setup Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Install tooling
        run: pip install pyyaml
      - name: Install lint tooling
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck curl
          curl -sSL https://github.com/hadolint/hadolint/releases/download/v2.12.0/hadolint-Linux-x86_64 -o hadolint
          sudo install hadolint /usr/local/bin/hadolint
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin

      - name: Shellcheck scripts
        run: |
          sh_files=$(git ls-files '*.sh')
          if [ -n "$sh_files" ]; then
            echo "$sh_files" | xargs -r shellcheck
          else
            echo 'No shell scripts to lint.'
          fi

      - name: Hadolint Dockerfiles
        run: |
          dockerfiles=$(git ls-files '*Dockerfile')
          if [ -n "$dockerfiles" ]; then
            echo "$dockerfiles" | xargs -n1 hadolint
          else
            echo 'No Dockerfiles to lint.'
          fi

      - name: Trivy filesystem scan
        run: |
          trivy fs --ignore-unfixed --severity CRITICAL,HIGH --exit-code 1 .

      - name: Repository checks
        run: make check

  package:
    needs: [determine-packages, lint]
    if: ${{ needs.determine-packages.outputs.packages != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJson(needs.determine-packages.outputs.packages) }}
    env:
      PACKAGE: ${{ matrix.package }}
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Setup Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install tooling
        run: pip install pyyaml

      - name: Run metadata tests
        run: ./scripts/package.py test "$PACKAGE"

      - name: Prepare metadata
        id: meta
        run: |
          python3 - <<'PY'
          import json
          import os
          from pathlib import Path
          import yaml

          package = os.environ['PACKAGE']
          metadata_path = Path('containers') / package / 'container.yaml'
          metadata = yaml.safe_load(metadata_path.read_text())

          def resolve(value):
              if isinstance(value, str) and value.startswith('!'):
                  node = metadata
                  for part in value[1:].split('.'):
                      if isinstance(node, dict) and part in node:
                          node = node[part]
                      else:
                          raise SystemExit(f"Unable to resolve token {value}")
                  return resolve(node)
              return value

          build_args = metadata.get('build', {}).get('args', {})
          resolved_args = {key: str(resolve(val)) for key, val in build_args.items()}
          image = metadata.get('publish', {}).get('image')
          if not image:
              raise SystemExit('publish.image must be defined')
          resolved_tags = [str(resolve(tag)) for tag in metadata.get('publish', {}).get('tags', [])]
          if not resolved_tags:
              raise SystemExit('publish.tags must contain at least one entry')
          full_tags = [f"{image}:{tag}" for tag in resolved_tags]
          version_tag = next((f"{image}:{tag}" for tag in resolved_tags if tag != 'latest'), full_tags[0])

          def write_output(name, value):
              with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as fh:
                  if isinstance(value, list):
                      fh.write(f"{name}<<EOF\n")
                      fh.write("\n".join(value) + "\n")
                      fh.write("EOF\n")
                  else:
                      fh.write(f"{name}={value}\n")

          write_output('image', image)
          write_output('tags', full_tags)
          if resolved_args:
              build_args_block = [f"{k}={v}" for k, v in resolved_args.items()]
              write_output('build_args', build_args_block)
          else:
              write_output('build_args', [])
          write_output('version_tag', version_tag)
          PY

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435

      - name: Docker login
        if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
        uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Build container image
        id: build
        uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25
        with:
          context: containers/${{ matrix.package }}
          file: containers/${{ matrix.package }}/Dockerfile
          push: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
          load: ${{ github.event_name != 'push' || github.ref != 'refs/heads/main' }}
          tags: ${{ steps.meta.outputs.tags }}
          build-args: ${{ steps.meta.outputs.build_args }}
          cache-from: type=gha,scope=${{ matrix.package }}
          cache-to: type=gha,mode=max,scope=${{ matrix.package }}

      - name: Pull pushed image
        if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
        run: docker pull "${{ steps.meta.outputs.version_tag }}"

      - name: Run end-to-end tests
        if: ${{ hashFiles(format('containers/{0}/tests/e2e.sh', matrix.package)) != '' }}
        env:
          SKIP_PACKAGE_BUILD: "1"
          SKIP_PACKAGE_TEST: "1"
          E2E_IMAGE: ${{ steps.meta.outputs.version_tag }}
        run: containers/${{ matrix.package }}/tests/e2e.sh

      - name: Install cosign
        if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
        uses: sigstore/cosign-installer@e1523de7571e31dbe865fd2e80c5c7c23ae71eb4
        with:
          cosign-release: 'v2.2.1'

      - name: Sign container images
        if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
        env:
          COSIGN_EXPERIMENTAL: '1'
        run: |
          echo "Signing tags:"
          printf '%s\n' "${{ steps.meta.outputs.tags }}" | while IFS= read -r tag; do
            [ -z "$tag" ] && continue
            echo "  $tag"
            cosign sign --yes "$tag"
          done
          cosign sign --yes "${{ steps.meta.outputs.image }}@${{ steps.build.outputs.digest }}"

      - name: Publish image digest summary
        if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
        run: |
          echo "Published ${{ steps.meta.outputs.version_tag }}" >> "$GITHUB_STEP_SUMMARY"
          echo "Digest: ${{ steps.build.outputs.digest }}" >> "$GITHUB_STEP_SUMMARY"
