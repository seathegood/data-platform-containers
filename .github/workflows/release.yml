name: Release

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      include_stable:
        description: 'Include stable tag (release events only by default)'
        required: false
        default: 'false'

permissions:
  contents: read
  packages: write
  id-token: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

env:
  PYTHON_VERSION: '3.11'

jobs:
  determine-packages:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.packages.outputs.packages }}
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Enumerate packages
        id: packages
        run: |
          set -euo pipefail
          packages=$(./scripts/package.py | awk '/^-/{print $2}' | grep -v '^_')
          PACKAGES="$packages" python3 - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          import os
          pkgs = [p for p in os.environ.get('PACKAGES', '').splitlines() if p]
          print(f"packages={json.dumps(pkgs)}")
          PY

  lint:
    needs: determine-packages
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
      - name: Setup Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Install tooling
        run: pip install pyyaml
      - name: Install lint tooling
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck curl
          curl -sSL https://github.com/hadolint/hadolint/releases/download/v2.12.0/hadolint-Linux-x86_64 -o hadolint
          sudo install hadolint /usr/local/bin/hadolint
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin

      - name: Shellcheck scripts
        run: |
          sh_files=$(git ls-files '*.sh')
          if [ -n "$sh_files" ]; then
            echo "$sh_files" | xargs -r shellcheck
          else
            echo 'No shell scripts to lint.'
          fi

      - name: Hadolint Dockerfiles
        run: |
          dockerfiles=$(git ls-files '*Dockerfile')
          if [ -n "$dockerfiles" ]; then
            echo "$dockerfiles" | xargs -n1 hadolint
          else
            echo 'No Dockerfiles to lint.'
          fi

      - name: Trivy filesystem scan
        run: |
          trivy fs --ignore-unfixed --severity CRITICAL,HIGH --exit-code 1 .

      - name: Repository checks
        run: make check

  package:
    needs: [determine-packages, lint]
    if: ${{ needs.determine-packages.outputs.packages != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJson(needs.determine-packages.outputs.packages) }}
    env:
      PACKAGE: ${{ matrix.package }}
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Setup Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install tooling
        run: pip install pyyaml

      - name: Prepare metadata
        id: meta
        run: |
          python3 - <<'PY'
          import json
          import os
          import re
          from pathlib import Path
          import yaml

          package = os.environ['PACKAGE']
          metadata_path = Path('containers') / package / 'container.yaml'
          metadata = yaml.safe_load(metadata_path.read_text())

          def resolve(value):
              if isinstance(value, str) and value.startswith('!'):
                  node = metadata
                  for part in value[1:].split('.'):
                      if isinstance(node, dict) and part in node:
                          node = node[part]
                      else:
                          raise SystemExit(f"Unable to resolve token {value}")
                  return resolve(node)
              return value

          build_args = metadata.get('build', {}).get('args', {})
          resolved_args = {key: str(resolve(val)) for key, val in build_args.items()}
          image = metadata.get('publish', {}).get('image')
          if not image:
              raise SystemExit('publish.image must be defined')
          resolved_tags = [str(resolve(tag)) for tag in metadata.get('publish', {}).get('tags', [])]
          if not resolved_tags:
              raise SystemExit('publish.tags must contain at least one entry')

          version = str(metadata.get('version', {}).get('current', '')).strip()
          semver_tags = []
          match = re.match(r'^(\d+)\.(\d+)\.(\d+)', version)
          if match:
              major, minor, patch = match.groups()
              semver_tags.extend([f"{major}", f"{major}.{minor}", f"{major}.{minor}.{patch}"])

          sha = os.environ.get('GITHUB_SHA', '')
          sha_tag = f"sha-{sha[:12]}" if sha else None

          def extend_unique(tags, items):
              for item in items:
                  if item and item not in tags:
                      tags.append(item)

          extend_unique(resolved_tags, semver_tags)
          if 'latest' not in resolved_tags:
              resolved_tags.append('latest')
          if os.environ.get('INCLUDE_STABLE') == '1':
              resolved_tags.append('stable')
          if sha_tag:
              resolved_tags.append(sha_tag)

          full_tags = [f"{image}:{tag}" for tag in resolved_tags]
          version_tag = f"{image}:{version}" if version else full_tags[0]

          def write_output(name, value):
              with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as fh:
                  if isinstance(value, list):
                      fh.write(f"{name}<<EOF\n")
                      fh.write("\n".join(value) + "\n")
                      fh.write("EOF\n")
                  else:
                      fh.write(f"{name}={value}\n")

          write_output('image', image)
          write_output('tags', full_tags)
          if resolved_args:
              build_args_block = [f"{k}={v}" for k, v in resolved_args.items()]
              write_output('build_args', build_args_block)
          else:
              write_output('build_args', [])
          write_output('version_tag', version_tag)
          PY
        env:
          INCLUDE_STABLE: ${{ (github.event_name == 'release' || github.event.inputs.include_stable == 'true') && '1' || '0' }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435

      - name: Log in to GHCR
        uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push container image
        id: build
        uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25
        with:
          context: containers/${{ matrix.package }}
          file: containers/${{ matrix.package }}/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: ${{ steps.meta.outputs.build_args }}
          cache-from: type=gha,scope=${{ matrix.package }}
          cache-to: type=gha,mode=max,scope=${{ matrix.package }}

      - name: Run metadata tests
        run: ./scripts/package.py test "$PACKAGE"

      - name: Install cosign
        uses: sigstore/cosign-installer@e1523de7571e31dbe865fd2e80c5c7c23ae71eb4
        with:
          cosign-release: 'v2.2.1'

      - name: Sign container images
        env:
          COSIGN_EXPERIMENTAL: '1'
        run: |
          echo "Signing tags:"
          printf '%s\n' "${{ steps.meta.outputs.tags }}" | while IFS= read -r tag; do
            [ -z "$tag" ] && continue
            echo "  $tag"
            cosign sign --yes "$tag"
          done
          cosign sign --yes "${{ steps.meta.outputs.image }}@${{ steps.build.outputs.digest }}"

      - name: Capture digest info
        run: |
          mkdir -p release-artifacts
          printf '%s\t%s\t%s\n' \
            "${{ matrix.package }}" \
            "${{ steps.meta.outputs.version_tag }}" \
            "${{ steps.build.outputs.digest }}" \
            > "release-artifacts/${{ matrix.package }}.tsv"

      - name: Upload digest artifact
        uses: actions/upload-artifact@v4
        with:
          name: digest-${{ matrix.package }}
          path: release-artifacts/${{ matrix.package }}.tsv

  release-notes:
    needs: package
    if: ${{ github.event_name == 'release' }}
    runs-on: ubuntu-latest
    permissions:
      # Needed to update the release body with digest notes.
      contents: write
    steps:
      - name: Download digest artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-artifacts

      - name: Assemble digest notes
        run: |
          {
            echo '### Platform Release'
            echo "- tag: ${GITHUB_REF_NAME}"
            echo
            echo '### Image Digests'
            for file in release-artifacts/**/**/*.tsv; do
              [ -f "$file" ] || continue
              read -r pkg tag digest <"$file"
              echo "- ${pkg}: ${tag} @ ${digest}"
            done
          } > digests.md

      - name: Update release notes
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        with:
          script: |
            const fs = require('fs');
            const content = fs.readFileSync('digests.md', 'utf8').trim();
            const release = context.payload.release;
            if (!release) {
              core.info('No release payload; skipping update.');
              return;
            }
            const marker = '### Image Digests';
            let body = release.body || '';
            if (body.includes(marker)) {
              body = body.replace(/### Image Digests[\s\S]*$/m, content);
            } else {
              body = body ? `${body}\n\n${content}` : content;
            }
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.id,
              body
            });
